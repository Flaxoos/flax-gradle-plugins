package io.flax.kover

import io.flax.kover.Names.KOVER_BADGE_EXTENSION_NAME
import kotlinx.css.Color
import kotlinx.kover.gradle.plugin.dsl.KoverNames
import kotlinx.kover.gradle.plugin.dsl.koverLogName
import org.gradle.api.DefaultTask
import org.gradle.api.file.Directory
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction
import java.io.File
import java.io.Serializable

private const val DECIMAL_FORMAT = "%.2f"
private const val SHIELDS_BADGE_URL = "https://img.shields.io/badge/"
private const val DEFAULT_BADGE_LABEL = "koverage"
private const val HTML_REPORT_INDEX_HTML = "index.html"

/**
 * Creates a badge in the readme for the test coverage as reported by [kotlinx.kover.gradle.plugin.KoverGradlePlugin]
 * The badge is generated by [shields.io](https://shields.io/badges/static-badge) and embedded in the readme where
 * the placeholder is found. The placeholder must conform to the following format:
 * ```
 * ![task.badge](any_string)
 * ```
 * After the task runs, the readme will contain the following:
 * ```
 * ![task.badge](https://img.shields.io/badge/100.0-blue?more-params...)
 * ```
 *
 * The url will also contain a link to the html report generated by
 * [kotlinx.kover.gradle.plugin.KoverGradlePlugin] if one exists
 */
abstract class KoverBadgeTask : DefaultTask() {

    companion object Regexes {
        private const val REPORT_URL_GROUP_NAME = "reportUrl"
        private const val SHIELDS_IO_URL_GROUP_NAME = "shieldsIsUrl"
        val coverageRegex = "application line coverage: (\\d+(\\.\\d+)?)%".toRegex()
        fun badgeWithReportLinkRegex(badgeLabelWithNoSpaces: String) =
            (
                "<a href=\"(?<$REPORT_URL_GROUP_NAME>.*?)\">!\\[$badgeLabelWithNoSpaces]" +
                    "\\((?<$SHIELDS_IO_URL_GROUP_NAME>.*?)\\)</a>"
                ).toRegex()

        val badgeWithoutReportLinkRegex =
            "<a>!\\[$DEFAULT_BADGE_LABEL]\\((?<$SHIELDS_IO_URL_GROUP_NAME>.*?)\\)</a>".toRegex()
    }

    /**
     * [KoverNames.DEFAULT_LOG_REPORT_NAME] result file
     */
    @get:PathSensitive(PathSensitivity.RELATIVE)
    @get:InputFile
    abstract val coverageLogFile: RegularFileProperty

    /**
     * [KoverNames.DEFAULT_HTML_REPORT_NAME] report dir, will exist only if
     * [kotlinx.kover.gradle.plugin.dsl.KoverNames.DEFAULT_HTML_REPORT_NAME] html reports are enabled by
     * ```
     * koverReport { defaults { html { onCheck = false } }}
     * ```
     * */
    @get:InputDirectory
    @get:Optional
    abstract val coverageHtmlReportDir: DirectoryProperty

    /**
     * The project readme file, to place the badge in
     */
    @get:OutputFile
    abstract val readme: RegularFileProperty

    /**
     * The label for the badge, spaces are not permitted and will be replaced with underscores
     */
    @get:Input
    abstract val badgeLabel: Property<String>

    /**
     * The style of the badge
     */
    @get:Input
    abstract val badgeStyle: Property<Style>

    /**
     * The color spectrum and coverage threshold for each color, meaning if coverage goes over a value,
     * the corresponding color will be used for the right side of the badge
     */
    @get:Input
    abstract val spectrum: ListProperty<ColorBand>

    @TaskAction
    fun editReadme() {
        val coverageLogFile = coverageLogFile.asFile.get()
        if (!coverageLogFile.exists()) {
            error("No coverage log file found, did the ${project.tasks.koverLogName} task run?")
        }
        val readmeFile = readme.get().asFile
        if (!readmeFile.exists()) {
            error(
                "No readme file found, make sure it exists and that it is pointed to in the " +
                    "$KOVER_BADGE_EXTENSION_NAME extension",
            )
        }

        val badgeLabelWithNoSpaces =
            badgeLabel.getOrElse(DEFAULT_BADGE_LABEL).also {
                if (it.contains(" ")) logger.info("Badge label must not contain spaces")
            }.replace(" ", "-").also {
                require(it.isNotEmpty()) { "Badge label must not be empty" }
            }

        val readmeContent = readmeFile.readText()
        val badgeWithReportLinkRegex = badgeWithReportLinkRegex(badgeLabelWithNoSpaces)
        val readmePlaceHolderMatch =
            badgeWithReportLinkRegex.find(readmeContent) ?: badgeWithoutReportLinkRegex.find(readmeContent)
        if (readmePlaceHolderMatch == null) {
            logger.warn(
                "${readmeFile.name} doesn't have the place holder for the kover badge, expecting: " +
                    "${badgeWithReportLinkRegex.pattern} or ${badgeWithoutReportLinkRegex.pattern}, " +
                    "readme content:\n$readmeContent",
            )
            return
        }

        val htmlReportDir =
            coverageHtmlReportDir.orNull.also { if (it == null) logger.quiet("No html report dir found") }
        val testCoverage = getTestCoverage(coverageLogFile)
        val coverageColor = getCoverageColor(testCoverage)
        val shieldsIoUrl = getBadgeUrl(testCoverage, coverageColor, badgeLabelWithNoSpaces)

        val updatedReadmeContent =
            badgeWithReportLinkRegex.updateReadmeIfMatches(
                readmeContent = readmeContent,
                htmlReportDir = htmlReportDir,
                shieldsIoUrl = shieldsIoUrl,
                badgeLabelWithNoSpaces = badgeLabelWithNoSpaces,
            ) ?: badgeWithoutReportLinkRegex.updateReadmeIfMatches(
                readmeContent = readmeContent,
                htmlReportDir = htmlReportDir,
                shieldsIoUrl = shieldsIoUrl,
                badgeLabelWithNoSpaces = badgeLabelWithNoSpaces,
            )
                ?: run {
                    logger.warn(
                        "Could not find the place holder for the kover badge, expecting: " +
                            "${badgeWithReportLinkRegex.pattern} or ${badgeWithoutReportLinkRegex.pattern}",
                    )
                    return
                }

        readmeFile.writeText(updatedReadmeContent)
        logger.quiet("Updated readme $readmeFile with $updatedReadmeContent")
    }

    private fun Regex.updateReadmeIfMatches(
        readmeContent: String,
        htmlReportDir: Directory?,
        shieldsIoUrl: String,
        badgeLabelWithNoSpaces: String,
    ) = if (this.find(readmeContent) != null) {
        if (htmlReportDir != null) {
            logger.quiet("Html report dir found")
            val htmlReportDirUrl = htmlReportDir.file(HTML_REPORT_INDEX_HTML).asFile.toURI().toURL()
            val textToInsert = "<a href=\"${htmlReportDirUrl}\">![$badgeLabelWithNoSpaces]($shieldsIoUrl)</a>"
            logger.quiet("replacing ${this.pattern} with $textToInsert")
            readmeContent.replace(this, textToInsert)
        } else {
            logger.quiet("Html report dir not found")
            val textToInsert = "<a>![$badgeLabelWithNoSpaces]($shieldsIoUrl)</a>"
            logger.quiet("replacing ${this.pattern} with $textToInsert")
            readmeContent.replace(this, textToInsert)
        }
    } else {
        logger.quiet("could not find ${this.pattern} in $readmeContent")
        null
    }

    private fun getBadgeUrl(testCoverage: Float, coverageColor: String, badgeLabelWithNoSpaces: String) =
        "$SHIELDS_BADGE_URL$testCoverage-$coverageColor" +
            "?logo=kotlin" +
            "&label=$badgeLabelWithNoSpaces" +
            "&style=${badgeStyle.get().value}"

    private fun getTestCoverage(koverLogFile: File): Float {
        val matchResult = coverageRegex.find(koverLogFile.readText())
        val testCoverage = matchResult?.groups?.get(1)?.value?.let { coverage ->
            DECIMAL_FORMAT.format(coverage.toFloat()).toFloat()
        } ?: error("No coverage found in kover log file. Did you set up the kover plugin correctly?")
        return testCoverage
    }

    @OptIn(ExperimentalStdlibApi::class)
    private fun getCoverageColor(testCoverage: Float) = spectrum.get()
        .sortedBy { band -> band.lowerThreshold }
        .zipWithNext()
        .firstOrNull { band ->
            testCoverage in band.first.lowerThreshold.rangeUntil(band.second.lowerThreshold)
        }?.first?.colorName ?: spectrum.get().last().colorName
}

/**
 *  A color band to be used in the [KoverBadgeTask.spectrum]
 *
 *  @param color The color of the band
 *  @param lowerThreshold The lower threshold for the color, meaning if the coverage is equal or over this value,
 *  the color will be used
 */
class ColorBand(color: Color, val lowerThreshold: Float) : Serializable {
    val colorName: String = color.value

    companion object {
        infix fun Color.from(lowerThreshold: Float) = ColorBand(this, lowerThreshold)
        infix fun String.from(lowerThreshold: Float) = ColorBand(Color(this), lowerThreshold)
        private const val serialVersionUID: Long = 1
    }

    // Need equals and hashCode as can't make data class because of Color not being serializable
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ColorBand

        if (lowerThreshold != other.lowerThreshold) return false
        if (colorName != other.colorName) return false

        return true
    }

    override fun hashCode(): Int {
        var result = lowerThreshold.hashCode()
        result = 31 * result + colorName.hashCode()
        return result
    }

    override fun toString(): String {
        return "ColorBand(lowerThreshold=$lowerThreshold, colorName='$colorName')"
    }
}

/**
 * The style to be chosen for the badge
 */
@Suppress("unused")
enum class Style(val value: String) : Serializable {
    Flat("flat"), FlatSquare("flat-square"), Plastic("plastic"), ForTheBadge("for-the-badge"), Social("social");

    companion object {
        private const val serialVersionUID: Long = 1
    }
}
