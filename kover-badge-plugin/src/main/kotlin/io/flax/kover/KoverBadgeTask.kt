package io.flax.kover

import io.flax.kover.Names.KOVER_BADGE_EXTENSION_NAME
import kotlinx.css.Color
import kotlinx.kover.gradle.plugin.dsl.KoverNames
import kotlinx.kover.gradle.plugin.dsl.koverLogName
import org.gradle.api.DefaultTask
import org.gradle.api.file.Directory
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.PathSensitive
import org.gradle.api.tasks.PathSensitivity
import org.gradle.api.tasks.TaskAction
import java.io.File
import java.io.Serializable

private const val DECIMAL_FORMAT = "%.2f"
private const val SHIELDS_BADGE_URL = "https://img.shields.io/badge/"
private const val KOVERAGE = "koverage"
private const val HTML_REPORT_INDEX_HTML = "index.html"

/**
 * Creates a badge in the readme for the test coverage as reported by [kotlinx.kover.gradle.plugin.KoverGradlePlugin]
 * The badge is generated by [shields.io](https://shields.io/badges/static-badge) and embedded in the readme where the placeholder is found.
 * The placeholder must conform to the following format:
 * ```
 * ![task.badge](any_string)
 * ```
 * After the task runs, the readme will contain the following:
 * ```
 * ![task.badge](https://img.shields.io/badge/100.0-blue?more-params...)
 * ```
 *
 * The url will also contain a link to the html report generated by [kotlinx.kover.gradle.plugin.KoverGradlePlugin] if one exists
 */
abstract class KoverBadgeTask : DefaultTask() {

    companion object Regexes {
        const val REPORT_URL_GROUP_NAME = "reportUrl"
        const val SHIELDS_IO_URL_GROUP_NAME = "shieldsIsUrl"
        val coverageRegex = "application line coverage: (\\d+)%".toRegex()
        val badgeWithReportLinkRegex =
            "<a href=\"(?<$REPORT_URL_GROUP_NAME>.*?)\">!\\[$KOVERAGE]\\((?<$SHIELDS_IO_URL_GROUP_NAME>.*?)\\)</a>".toRegex()
        val badgeWithoutReportLinkRegex =
            "<a>!\\[$KOVERAGE]\\((?<$SHIELDS_IO_URL_GROUP_NAME>.*?)\\)</a>".toRegex()
    }

    /**
     * [KoverNames.DEFAULT_VERIFY_REPORT_NAME] result file
     */
    @get:PathSensitive(PathSensitivity.RELATIVE)
    @get:InputFile
    abstract val koverLogResultFile: RegularFileProperty

    /**
     * [KoverNames.DEFAULT_HTML_REPORT_NAME] report dir, will exist only if
     * [kotlinx.kover.gradle.plugin.dsl.KoverNames.DEFAULT_HTML_REPORT_NAME] html reports are enabled by
     * ```
     * koverReport { defaults { html { onCheck = false } }}
     * ```
     * */
    @get:InputDirectory
    @get:Optional
    abstract val koverHtmlReportDir: DirectoryProperty

    /**
     * The project readme file, to place the badge in
     */
    @get:OutputFile
    abstract val readme: RegularFileProperty

    /**
     * The label for the badge
     */
    @get:Input
    abstract val badgeLabel: Property<String>

    /**
     * The style of the badge
     */
    @get:Input
    abstract val badgeStyle: Property<Style>

    /**
     * The color spectrum and coverage threshold for each color, meaning if coverage goes over a value,
     * the corresponding color will be used for the right side of the badge
     */
    @get:Input
    abstract val spectrum: ListProperty<ColorBand>

    @TaskAction
    fun editReadme() {
        val koverLogFile = koverLogResultFile.asFile.get()
        if (!koverLogFile.exists()) {
            logger.warn("No kover log file found, did the ${project.tasks.koverLogName} task run?")
            return
        }

        val readmeFile = readme.get().asFile
        if (!readmeFile.exists()) {
            logger.warn("No readme file found, make sure it exists and that it is pointed to in the $KOVER_BADGE_EXTENSION_NAME extension")
            return
        }

        if (badgeLabel.get().contains(" ")) {
            logger.warn("spaces are not allowed in badges, replaced with dash")
            badgeLabel.set(badgeLabel.get().replace(" ", "-"))
        }

        val readmeContent = readmeFile.readText()

        val readmePlaceHolderMatch =
            badgeWithReportLinkRegex.find(readmeContent) ?: badgeWithoutReportLinkRegex.find(readmeContent)
        if (readmePlaceHolderMatch == null) {
            logger.warn("${readmeFile.name} doesn't have the place holder for the kover badge, expecting: ${badgeWithReportLinkRegex.pattern} or ${badgeWithoutReportLinkRegex.pattern}")
            return
        }

        val htmlReportDir = koverHtmlReportDir.orNull
        val testCoverage = getTestCoverage(koverLogFile)
        val coverageColor = getCoverageColor(testCoverage)
        val shieldsIoUrl = getBadgeUrl(testCoverage, coverageColor)

        val updatedReadmeContent =
            badgeWithReportLinkRegex.updateReadmeIfMatches(
                readmeContent = readmeContent,
                htmlReportDir = htmlReportDir,
                shieldsIoUrl = shieldsIoUrl
            ) ?: badgeWithoutReportLinkRegex.updateReadmeIfMatches(
                readmeContent = readmeContent,
                htmlReportDir = htmlReportDir,
                shieldsIoUrl = shieldsIoUrl,
            )
            ?: run {
                logger.warn("Could not find the place holder for the kover badge, expecting: ${badgeWithReportLinkRegex.pattern} or ${badgeWithoutReportLinkRegex.pattern}")
                return
            }

        readmeFile.writeText(updatedReadmeContent)
    }

    private fun Regex.updateReadmeIfMatches(
        readmeContent: String,
        htmlReportDir: Directory?,
        shieldsIoUrl: String,
    ) = if (this.find(readmeContent) != null) {
        if (htmlReportDir != null) {
            val textToInsert = "<a href=\"${
                htmlReportDir.file(HTML_REPORT_INDEX_HTML).asFile.toURI().toURL()
            }\">![${badgeLabel.get()}]($shieldsIoUrl)</a>"
            logger.quiet("replacing ${this.pattern} with $textToInsert")
            readmeContent.replace(this, textToInsert)
        } else {
            val textToInsert = "<a>![${badgeLabel.get()}]($shieldsIoUrl)</a>"
            logger.quiet("replacing ${this.pattern} with $textToInsert")
            readmeContent.replace(this, textToInsert)
        }
    } else null

    private fun getBadgeUrl(testCoverage: Float, coverageColor: String) =
        "$SHIELDS_BADGE_URL$testCoverage-$coverageColor" +
            "?logo=kotlin" +
            "&label=${badgeLabel.get()}" +
            "&style=${badgeStyle.get().value}"
    private fun getTestCoverage(koverLogFile: File): Float {
        val matchResult = coverageRegex.find(koverLogFile.readText())
        val testCoverage = matchResult?.groups?.get(1)?.value?.let { coverage ->
            DECIMAL_FORMAT.format(coverage.toFloat()).toFloat()
        } ?: error("No coverage found in kover log file. Did you set up the kover plugin correctly?")
        return testCoverage
    }

    @OptIn(ExperimentalStdlibApi::class)
    private fun getCoverageColor(testCoverage: Float) = spectrum.get()
        .sortedBy { band -> band.lowerThreshold }
        .zipWithNext()
        .firstOrNull { band ->
            testCoverage in band.first.lowerThreshold..<band.second.lowerThreshold
        }?.first?.colorName ?: spectrum.get().last().colorName

}

/**
 *  A color band to be used in the [KoverBadgeTask.spectrum]
 *
 *  @param color The color of the band
 *  @param lowerThreshold The lower threshold for the color, meaning if the coverage is equal or over this value,
 *  the color will be used
 */
class ColorBand(color: Color, val lowerThreshold: Float) : Serializable {

    val colorName: String = color.value

    companion object {
        infix fun Color.from(threshold: Float) = ColorBand(this, threshold)
        infix fun String.from(threshold: Float) = ColorBand(Color(this), threshold)
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as ColorBand

        if (lowerThreshold != other.lowerThreshold) return false
        if (colorName != other.colorName) return false

        return true
    }

    override fun hashCode(): Int {
        var result = lowerThreshold.hashCode()
        result = 31 * result + colorName.hashCode()
        return result
    }

}

/**
 * The style to be chosen for the badge
 */
@Suppress("unused")
enum class Style(val value: String) : Serializable {
    Flat("flat"), FlatSquare("flat-square"), Plastic("plastic"), ForTheBadge("for-the-badge"), Social("social")
}
